importScripts("https://unpkg.com/pbf@3.2.0/dist/pbf.js", "./comlink.js");

const filterVal = (val, scale) => {
  if (val > -998) {
    return val * scale;
  }
  if (val === -999) {
    return null;
  }
  if (val === -9999) {
    return undefined;
  }
  if (isNaN(val)) {
    return null;
  }
  return val * scale;
};

const parsePbfData = (pbfData, fileInfo, dateList) => {
  let returnData = {};
  let dateIndices = [];
  let constructorIndices = [];
  let columnNames = ["geoid", ...pbfData.dates];
  // embedded scientific scale exponent in file name
  const scale = /.e-[0-9]/g.exec(fileInfo.file)
    ? 10 ** -+/.e-[0-9]/g.exec(fileInfo.file)[0]?.split("-")[1]
    : 1;

  for (let i = 0; i < dateList.length; i++) {
    if (pbfData.dates.includes(dateList[i])) {
      dateIndices.push(i);
      constructorIndices.push(true);
    } else {
      constructorIndices.push(false);
    }
  }

  if (fileInfo.accumulate) {
    for (let i = 0; i < pbfData.row.length; i++) {
      returnData[pbfData.row[i].geoid] = [];
      for (let n = 0, j = 0; n < constructorIndices.length; n++) {
        if (constructorIndices[n]) {
          returnData[pbfData.row[i].geoid].push(
            pbfData.row[i].vals[j] <= -999
              ? pbfData.row[i].vals[j] === -999
                ? null
                : undefined
              : (pbfData.row[i].vals[j] * scale || 0) +
                  (returnData[pbfData.row[i].geoid][n - 1] || 0) || null
          );
          j++;
        } else {
          returnData[pbfData.row[i].geoid].push(
            pbfData.row[i].vals[j] <= -999
              ? pbfData.row[i].vals[j] === -999
                ? null
                : undefined
              : pbfData.row[i].vals[j - 1] * scale || null
          );
        }
      }
    }
  } else {
    for (let i = 0; i < pbfData.row.length; i++) {
      returnData[pbfData.row[i].geoid] = [];
      for (let n = 0, j = 0; n < constructorIndices.length; n++) {
        if (constructorIndices[n]) {
          returnData[pbfData.row[i].geoid].push(
            filterVal(pbfData.row[i].vals[j], scale)
          );
          j++;
        } else {
          returnData[pbfData.row[i].geoid].push(
            filterVal(pbfData.row[i].vals[j - 1], scale)
          );
        }
      }
    }
  }
  return { data: returnData, columns: columnNames, dates: dateIndices };
};

// code generated by pbf v3.2.1

// Dot ========================================

var Dot = {};

Dot.read = function (pbf, end) {
  return pbf.readFields(Dot._readField, { val: [] }, end);
};
Dot._readField = function (tag, obj, pbf) {
  if (tag === 1) pbf.readPackedVarint(obj.val, true);
};
Dot.write = function (obj, pbf) {
  if (obj.val) pbf.writePackedVarint(1, obj.val);
};

// Entry ========================================

var Entry = {};

Entry.read = function (pbf, end) {
  return pbf.readFields(Entry._readField, { geoid: 0, vals: [] }, end);
};
Entry._readField = function (tag, obj, pbf) {
  if (tag === 1) obj.geoid = pbf.readVarint(true);
  else if (tag === 2) pbf.readPackedVarint(obj.vals, true);
};
Entry.write = function (obj, pbf) {
  if (obj.geoid) pbf.writeVarintField(1, obj.geoid);
  if (obj.vals) pbf.writePackedVarint(2, obj.vals);
};

// Rows ========================================

var Rows = {};

Rows.read = function (pbf, end) {
  return pbf.readFields(Rows._readField, { dates: [], row: [] }, end);
};
Rows._readField = function (tag, obj, pbf) {
  if (tag === 1) obj.dates.push(pbf.readString());
  else if (tag === 2) obj.row.push(Entry.read(pbf, pbf.readVarint() + pbf.pos));
};
Rows.write = function (obj, pbf) {
  if (obj.dates)
    for (var i = 0; i < obj.dates.length; i++)
      pbf.writeStringField(1, obj.dates[i]);
  if (obj.row)
    for (i = 0; i < obj.row.length; i++)
      pbf.writeMessage(2, Entry.write, obj.row[i]);
};

function parsePbfWorker(ab) {
  return parsePbfData(Rows.read(new Pbf(ab)))
}
// Expose it to Comlink
Comlink.expose(parsePbfWorker);
